{
    "contents" : "# X = X_train; y = y_train ; \n# n=100; r=30 ; num_iterations=50 ;burnin=40; generator=123 ;q=2/3\n\n\nGauss_inf = function(X,y,sigma,n,r,sigmaRBF,q,generator,num_iterations,burnin){\n  ##precompute features\n  D = ncol(X);\n  res = matrix(,num_iterations+1,n^D);alpha = matrix(,num_iterations,D)\n  Phi_vec = apply(X,1,function(x){Reduce(kronecker,alply(array(feature(x,n,sigmaRBF,generator),c(n,D)),2)) })\n  Phi_vec_array = array(,c(n^(D-1),nrow(X),D))   ###Phi_{-j}\n  for (j in 1:D) {\n    Phi_vec_array[,,j] = apply(X,1,function(x){Reduce(kronecker,alply(array(feature(x,n,sigmaRBF,generator)[,-j],c(n,D-1)),2)) })\n  }\n  \n  b = array(,c(n,nrow(X),D))\n  for (j in 1:D){\n    for (i in 1:nrow(X)){\n      b[,i,j] = feature(X[i,],n,sigmaRBF,generator)[,j]\n    }\n  }\n  \n  #initialise U's\n  sigma_j = sqrt(1/r)\n  U_array = array(,c(n,r,ncol(X)))\n  for (j in 1:ncol(X)){U_array[,,j] = matrix(sigma_j*rnorm(n*r),n,r)}\n  ##initialise W\n  w = rep(0,r^D)\n  I = sort(sample(1:(r^D))[1:(q*r^D)])\n  w[I] = sqrt(1/q) * rnorm(length(I))\n  res[1,] = Reduce(kronecker,alply(U_array,3))[,I] %*% w[I]\n  \n  U = Reduce(kronecker,alply(U_array,3)) \n  U_I = U[,I]\n  \n  ###inference\n  for (m in 1:num_iterations){\n    ##posterior for the core tensor W    \n    tmp0 = apply(X,1,function(x){\n      Reduce(kronecker,lapply(1:D,function(z){t(U_array[,,z]) %*% feature(x,n,sigmaRBF,generator)[,z]}))[I] } )   \n    Sigma = chol2inv(chol( q * diag(q*r^D) + (tmp0 %*% (t(tmp0)/(sigma^2))) ))\n    w[I] = Sigma %*% (t(U_I) %*% (Phi_vec %*% y)) /(sigma^2)\n    W = aperm(array(w,rep(r,D)),rev(1:D))\n#     W = array(w,rep(r,D))\n    \n    \n    ##posterior on the Us \n    for (j in 1:D){\n      \n      Wj = array(aperm(W,c(j,(1:D)[-j])),c(r,r^(D-1)))\n      \n      #form U_(minus j)\n      if (D==2) {Uj = U_array[,,(1:D)[-j]]}\n      else {Uj = Reduce(kronecker,alply(array(U_array[,,-j],c(n,r,D-1)),3))}\n      \n      a = matrix(,r,nrow(X));C = matrix(,r*n,nrow(X));#C1 = matrix(,r*n,nrow(X))\n      for (i in 1:nrow(X)){ a[,i] = Wj %*% (t(Uj) %*% Phi_vec_array[,i,j]) \n                            C[,i] = kronecker(a[,i],b[,i,j])\n                           # C1[,i] = kronecker(b[,i,j],a[,i])\n                                                              }\n      \n#       M = (sigma/sigma_j)^2* diag(n*r)\n#       for (z in 1:nrow(X)) {\n#         tmp =   C[,z] %*%  M \n#         M = M - t(tmp) %*% tmp /as.numeric( 1 + tmp %*% C[,z])\n#       }\n#       log_pi = function(u) {  \n#          Reduce(\"+\", lapply(c(1:nrow(X)),function(x){ tmp1 = t(b[,x,j]) %*% u %*% a[,x]\n#               return(-1/(2*sigma^2) * tmp1^2 + y[x] * tmp1 /(sigma^2))  } )) - 1/(2*sigma_j^2) * sum(u^2) }  \n\n#       print(paste(\"before = \", log_pi(U_array[,,j])))\n\n      U_array[,,j] = matrix(solve(C %*% t(C) + (sigma/sigma_j)^2 * diag(n*r)) %*% (C %*% y),n,r)\n#       print(paste(\"after = \", log_pi(U_array[,,j])))\n\n#       logl[m] = log_pi(U_array[,,j])\n    } \n    \n    U_I = Reduce(kronecker,alply(U_array,3))[,I]\n    TMP = U_I %*% w[I]\n    if ( m > burnin) {res[m+1,] = (TMP + res[m,])/2 }\n    else { res[m+1,] = TMP }  \n\n#     f_hat = t(Phi_vec) %*% res[m+1,]\n#     f_hat = unlist(lapply(c(1:nrow(X)),function(x){ t(b[,x,j]) %*% U_array[,,j] %*% a[,x] }))    \n#     print(sqrt(sum((f_hat-f[1:nrow(X_train)])^2)/nrow(X)))\n     print(m)\n  }\n  return(res)\n}\n",
    "created" : 1432250363237.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "85454392",
    "id" : "B8699B53",
    "lastKnownWriteTime" : 1432242978,
    "path" : "C:/Users/Xiaoyu Lu/Dropbox/GP/GPT-master/R/inf_Gauss2.R",
    "project_path" : "R/inf_Gauss2.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}